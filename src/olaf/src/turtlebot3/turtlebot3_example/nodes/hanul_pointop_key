#!/usr/bin/env python
<<<<<<< HEAD
=======
#################################################################################
# Copyright 2018 ROBOTIS CO., LTD.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#################################################################################

# Authors: Gilbert #
>>>>>>> wall_detection

import rospy
from geometry_msgs.msg import Twist, Point, Quaternion
import tf
from math import radians, copysign, sqrt, pow, pi, atan2
from tf.transformations import euler_from_quaternion
import numpy as np
<<<<<<< HEAD
import signal
import sys
from std_msgs.msg import Int32MultiArray
from std_msgs.msg import Float32MultiArray
from path_list import Path_Node


MAX_LIN_VEL = 0
CUR_LIN_VEL = 0
BURGER_MAX_ANG_VEL = 1.5
ANG_VEL_STEP_SIZE = 0.1

last_target_angle = 0

LAST_TARGET_POINT_X = 0
LAST_TARGET_POINT_Y = 0

g_lane_location = 0 

FRONT_DIST = 0.0
RIGHT_DIST = 0.0
LEFT_DIST = 0.0


class GotoPoint():
    def __init__(self, path_list):
        #### set global variable ####
        global LAST_TARGET_POINT_X
        global LAST_TARGET_POINT_Y
        
        #### from pkg:vision import test.py ######
        global g_lane_location
        
        #### initialize ros_node olaf_pointop #####
        rospy.init_node('olaf_pointop', anonymous=False)
        rospy.on_shutdown(self.shutdown)
        #### create publisher ####
        self.cmd_vel = rospy.Publisher('cmd_vel', Twist, queue_size=5)
        
        
        #### declare messages to publish ####
        position = Point()
        move_cmd = Twist()        
        x_location = Point()
        
        
        
        self.lane_location = 0
        self.rate = rospy.Rate(10)
        self.tf_listener = tf.TransformListener()
        
        
        #### declare odom_frame variable ####
        self.odom_frame = 'odom'
        
        #### Subscribe 'lane_data' topic from vision pkg test.py ####
        self.lane_location_sub = rospy.Subscriber("lane_data",Int32MultiArray,self.callback)
        #### Subscribe 'from_lidar_to_avoid' topic from turtlebot3_obstacle pkg ####
        self.lidar_distance = rospy.Subscriber("from_lidar_to_avoid", Float32MultiArray, self.lidar_callback)
        
        #### set up odometry information ####
        self.TF_LISTEN()
        
        #### get path_list ####
        (goal_x, goal_y, goal_z) = (path_list[0], path_list[1], path_list[2])
        #### get state information: 
        ####
        #### 	0 - on_drive
        ####	1 - arrive_at_dest
        ####	2 - return_to_start_pos
        ####
        goal_flag = path_list[3]
        
        #### call funtions ####
        self.rotate_before_move(goal_x, goal_y, path_list[2])
        #self.move(goal_x, goal_y, goal_flag)
        self.go_to_elevator(goal_x, goal_y, goal_flag)
        
        #### reset TARGET_POINT ####
        LAST_TARGET_POINT_X = goal_x
        LAST_TARGET_POINT_Y = goal_y
    
    #### opencv callback function ####    
    def callback(self,msg):
        #### get center pixel of tile from vision pkg ####
        global g_lane_location
        g_lane_location = msg.data[0]
    
    
    #### lidar callback funtion ####    
    def lidar_callback(self, msg):
        #### get lidar data from turtlebot3_obstacle pkg ####
        global FRONT_DIST, RIGHT_DIST, LEFT_DIST
        FRONT_DIST, RIGHT_DIST, LEFT_DIST = msg.data

    
    #### rotate_before_move function ####
    def rotate_before_move(self, target_x, target_y, target_z):
        #### set global_variable ####
        global last_target_angle, FRONT_DIST, RIGHT_DIST, LEFT_DIST
        
        #### get odom data; position and rotation ####
        (position, rotation) = self.get_odom()
        
        #### calculate difference between goal_pos and current_pos ####
        (x_diff, y_diff) = (target_x - position.x, target_y - position.y)
        
        
        #### declare message to publish; type Twist ####
        turn_cmd = Twist()
        turn_cmd.linear.x = 0.0
        
        
        #### type changing; float to integer ####
        (x_diff, y_diff) = (int(x_diff), int(y_diff))

        #### set variable ####
        target_angle = 0.0
        target_angle = target_z    
        last_target_angle = target_angle

        #### convert target_angle; degree to radian ####
        target_angle = np.deg2rad(target_angle)
        print("x_diff :" + str(x_diff))
        print("y_diff :" + str(y_diff))
        print("target_angle :" + str(target_angle))

        #### move ratate ####
        while abs(rotation - target_angle) > 0.05:

            (position, rotation) = self.get_odom()
            if target_angle > 0:
                #### rotate left ####
                if rotation <= target_angle and rotation >= target_angle - pi:
                    turn_cmd.angular.z = 0.5
                #### rotate right  ####
                else:
                    turn_cmd.angular.z = -0.5
            else:
                #### rotate right ####
                if rotation <= target_angle + pi and rotation > target_angle:
                    turn_cmd.angular.z = -0.5
                #### ratate left ####
                else:
                    turn_cmd.angular.z = 0.5
                    
                    
            #### publish turn_cmd message ####
            self.cmd_vel.publish(turn_cmd)
            self.rate.sleep()
        
        rospy.loginfo("Stopping the robot...")
        
    #### go_to_elevator ####
    def go_to_elevator(self, target_x, target_y, returned_flag) :
        global MAX_LIN_VEL
        global LAST_TARGET_POINT_X
        global LAST_TARGET_POINT_Y
        global g_lane_location
        global FRONT_DIST, LEFT_DIST, RIGHT_DIST
        
        lane_location = g_lane_location
        move_cmd = Twist()
        (position, rotation) = self.get_odom()
        last_rotation = 0.0
        
        right_target_distance = 0.8
        left_target_distance = 2.5
        
        my_position_x = LAST_TARGET_POINT_X
        my_position_y = LAST_TARGET_POINT_Y
        
        print("position : ", position)
        
        if target_x != LAST_TARGET_POINT_X:
            distance = sqrt(pow(target_x - my_position_x,2))
        elif target_y != LAST_TARGET_POINT_Y:
            distance = sqrt(pow(target_y - my_position_y,2))
        else:
            distance = 0
            
        while distance > 0.05 :
            (position, rotation) = self.get_odom()
            
            x_start = position.x
            y_start = position.y
            
            print("front_dist : ", FRONT_DIST)
            print("right_dist : ", RIGHT_DIST)
            print("left_dist : ", LEFT_DIST)
            
            if target_x != LAST_TARGET_POINT_X:
                x_start = position.x
                y_start = LAST_TARGET_POINT_Y
            elif target_y != LAST_TARGET_POINT_Y:
                x_start = LAST_TARGET_POINT_X
                y_start = position.y
            else:
                x_start = LAST_TARGET_POINT_X
                y_start = LAST_TARGET_POINT_Y
                
            path_angle = atan2(target_y - y_start, target_x - x_start)
            
            
            
            if returned_flag == 1 :
                move_cmd.angular.z = 0.0
                if RIGHT_DIST < 0.7 and RIGHT_DIST > 0.3 and LEFT_DIST > 2.6 and LEFT_DIST < 3.2:
                    move_cmd.angular.z = (right_target_distance - RIGHT_DIST)*0.05
                    print("---------Right Wall Collision---------")
                elif RIGHT_DIST > 0.9 and RIGHT_DIST < 1.3 and LEFT_DIST < 2.4 and LEFT_DIST > 2.0:
                    print("---------Left Wall Collision---------")
                    move_cmd.angular.z = (right_target_distance - RIGHT_DIST)*0.05
                else:
                    pass 
                if RIGHT_DIST > 1.0 and RIGHT_DIST < 1.2:
                    move_cmd.angular.z = (right_target_distance - RIGHT_DIST) *0.05
                
                
                
            else :
                lane_diff = (330.0 - float(g_lane_location))
            
                #### calculate angular by vision data ####
                if returned_flag == 2 and distance < 2:
                    move_cmd.angular.z = path_angle - rotation
                    print("&&&&&&&&&&&odom_control&&&&&&&&&&&&&&&&&&")
                elif abs(lane_diff) <= 30:
                    move_cmd.angular.z = path_angle - rotation
                    print("&&&&&&&&&&&odom_control&&&&&&&&&&&&&&&&&&")
                elif abs(lane_diff) > 30 and abs(lane_diff) < 80:
                    move_cmd.angular.z = lane_diff/33000
                    if MAX_LIN_VEL > 0.25:
                        MAX_LIN_VEL -= 0.005
                    print("***********lane_contorl111111111________________")
                elif abs(lane_diff) >= 80:
                    if MAX_LIN_VEL > 0.25:
                        MAX_LIN_VEL -= 0.05
                    move_cmd.angular.z = lane_diff/3300*5
                    print("***********lane_contorl2222222________________")
                
                
                
                
             
                
            
            if target_x != LAST_TARGET_POINT_X:
                distance = sqrt(pow(target_x - x_start,2))
            elif target_y != LAST_TARGET_POINT_Y:
                distance = sqrt(pow(target_y - y_start,2))
            else:
                distance = 0
                
            #distance = sqrt(pow(target_x - position.x, 2) + pow(target_y - position.y, 2))
            if MAX_LIN_VEL < 0.18:
                MAX_LIN_VEL+=0.001
            move_cmd.linear.x = min(distance, MAX_LIN_VEL)
            
            print("distance : ", distance)
            print("position x : ",position.x)
            print("position y : ",position.y)
            print("angular.z " , move_cmd.angular.z)
            
            print("target_x : ", target_x)
            print("target_y : ", target_y)
            
            last_rotation = rotation
            self.cmd_vel.publish(move_cmd)
            self.rate.sleep()
            
        MAX_LIN_VEL = 0

    
    
    def TF_LISTEN(self):
        try:
            self.tf_listener.waitForTransform(self.odom_frame, 'base_footprint', rospy.Time(), rospy.Duration(1.0))
            self.base_frame = 'base_footprint'
        except (tf.Exception, tf.ConnectivityException, tf.LookupException):
            try:
                self.tf_listener.waitForTransform(self.odom_frame, 'base_link', rospy.Time(), rospy.Duration(1.0))
                self.base_frame = 'base_link'
            except (tf.Exception, tf.ConnectivityException, tf.LookupException):
                rospy.loginfo("Cannot find transform between odom and base_link or base_footprint")
                rospy.signal_shutdown("tf Exception")
    
    
    #### get_odom data : current x,y point and rotation ####
=======
from sensor_msgs.msg import LaserScan

msg = """
control your Turtlebot3!
-----------------------
Insert xyz - coordinate.
x : position x (m)
y : position y (m)
z : orientation z (degree: -180 ~ 180)
If you want to close, insert 's'
-----------------------
"""

class GotoPoint():
    def __init__(self, path_list): ### path_list parameter added
        rospy.init_node('turtlebot3_pointop_key', anonymous=False)
        rospy.on_shutdown(self.shutdown)
        self.cmd_vel = rospy.Publisher('cmd_vel', Twist, queue_size=5)
        
        ### dahun modified source lines ###
        rospy.Subscriber('scan', LaserScan, hlds_callback)
        ### dahun modified source lines ###
        
        position = Point()
        move_cmd = Twist()
        r = rospy.Rate(10)
        self.tf_listener = tf.TransformListener()
        self.odom_frame = 'odom'

        try:
            self.tf_listener.waitForTransform(self.odom_frame, 'base_footprint', rospy.Time(), rospy.Duration(1.0))
            self.base_frame = 'base_footprint'
        except (tf.Exception, tf.ConnectivityException, tf.LookupException):
            try:
                self.tf_listener.waitForTransform(self.odom_frame, 'base_link', rospy.Time(), rospy.Duration(1.0))
                self.base_frame = 'base_link'
            except (tf.Exception, tf.ConnectivityException, tf.LookupException):
                rospy.loginfo("Cannot find transform between odom and base_link or base_footprint")
                rospy.signal_shutdown("tf Exception")

        (position, rotation) = self.get_odom()
        last_rotation = 0
        linear_speed = 1
        angular_speed = 1
        ### sunpil modified source lines ###
        #(goal_x, goal_y, goal_z) = self.getkey()
        (goal_x, goal_y, goal_z) = (path_list[0],path_list[1],path_list[2])
        ### sunpil modified source lines ###
        if goal_z > 180 or goal_z < -180:
            print("you input wrong z range.")
            self.shutdown()
        goal_z = np.deg2rad(goal_z)
        goal_distance = sqrt(pow(goal_x - position.x, 2) + pow(goal_y - position.y, 2))
        distance = goal_distance

        while distance > 0.05:
            (position, rotation) = self.get_odom()
            x_start = position.x
            y_start = position.y
            path_angle = atan2(goal_y - y_start, goal_x- x_start)

            if path_angle < -pi/4 or path_angle > pi/4:
                if goal_y < 0 and y_start < goal_y:
                    path_angle = -2*pi + path_angle
                elif goal_y >= 0 and y_start > goal_y:
                    path_angle = 2*pi + path_angle
            if last_rotation > pi-0.1 and rotation <= 0:
                rotation = 2*pi + rotation
            elif last_rotation < -pi+0.1 and rotation > 0:
                rotation = -2*pi + rotation
            move_cmd.angular.z = angular_speed * path_angle-rotation

            distance = sqrt(pow((goal_x - x_start), 2) + pow((goal_y - y_start), 2))
            
            ### dahun modified source lines ###
            if self.hlds_data.ranges[0] > 100.0:
                move_cmd.linear.x = min(linear_speed * distance, 0.1)
            else:
                break
            ### dahun modified source lines ###

            if move_cmd.angular.z > 0:
                move_cmd.angular.z = min(move_cmd.angular.z, 1.5)
            else:
                move_cmd.angular.z = max(move_cmd.angular.z, -1.5)

            last_rotation = rotation
            
            ###hanul lines ####
            go_forward()
            ###hanul lines ###
            
            
            self.cmd_vel.publish(move_cmd)
            r.sleep()
        (position, rotation) = self.get_odom()

        while abs(rotation - goal_z) > 0.05:
            (position, rotation) = self.get_odom()
            if goal_z >= 0:
                if rotation <= goal_z and rotation >= goal_z - pi:
                    move_cmd.linear.x = 0.00
                    move_cmd.angular.z = 0.5
                else:
                    move_cmd.linear.x = 0.00
                    move_cmd.angular.z = -0.5
            else:
                if rotation <= goal_z + pi and rotation > goal_z:
                    move_cmd.linear.x = 0.00
                    move_cmd.angular.z = -0.5
                else:
                    move_cmd.linear.x = 0.00
                    move_cmd.angular.z = 0.5
            self.cmd_vel.publish(move_cmd)
            r.sleep()

        rospy.loginfo("Stopping the robot...")
        self.cmd_vel.publish(Twist())

    def getkey(self):
        x, y, z = raw_input("| x | y | z |\n").split()
        if x == 's':
            self.shutdown()
        x, y, z = [float(x), float(y), float(z)]
        return x, y, z

>>>>>>> wall_detection
    def get_odom(self):
        try:
            (trans, rot) = self.tf_listener.lookupTransform(self.odom_frame, self.base_frame, rospy.Time(0))
            rotation = euler_from_quaternion(rot)

        except (tf.Exception, tf.ConnectivityException, tf.LookupException):
            rospy.loginfo("TF Exception")
            return

        return (Point(*trans), rotation[2])
<<<<<<< HEAD
        
=======

>>>>>>> wall_detection

    def shutdown(self):
        self.cmd_vel.publish(Twist())
        rospy.sleep(1)
        
<<<<<<< HEAD
        
#### Force quit ####
def handler(signum, f):
    print signum
    sys.exit()

if __name__ == '__main__':
    
    #### get path_node by path_list.py ####
    path_node = Path_Node()
    path_list = path_node.get_path_list("test")
    
    #### print paht_list point ####
    print("++++++++++++")
    print("path_lists")
    for p in path_list:
        print(p)
    print("++++++++++++")
    
    count = 0

    #### FORCE quit ####
    signal.signal(signal.SIGINT, handler)

    #### navigation ####
    while not rospy.is_shutdown():
    
        GotoPoint(path_list[count])
        count += 1
        
        
        if count > len(path_list):
            break
=======
    ### dahun modified source lines ###
    def hlds_callback(self, data):
        self.hlds_data = data
        
    ### dahun modified source lines ###
    ### sunpil modified source lines ###
def path_calc(start_x, start_y, target_x, target_y):
    arrived = False
    topic_list = list()
    control_topic = np.array([0,0,0])
    start_z = 0
    current_x = start_x
    current_y = start_y
    current_z = 0
    point_z = 0
    while(1):
        if not arrived:
            if target_x != current_x:
                print("target_x != current_x")
                control_topic[0] = target_x - current_x
                if target_y - start_y < 0:
                    control_topic[2] = -90
                    current_z = -90
                    point_z = -90
                elif target_y - start_y > 0:
                    control_topic[2] = 90
                    current_z = 90
                    point_z = 90
                    tmp_control = np.array(control_topic)
                    topic_list.append(tmp_control)
                    current_x = control_topic[0]
                    current_y = control_topic[1]
                    current_z = control_topic[2]
            elif target_x == current_x and target_y != current_y:
                print("target_x == current_x and target_y != current_y")
                control_topic[1] = target_y - start_y
                tmp_control = np.array(control_topic)
                topic_list.append(tmp_control)
                current_x = control_topic[0]
                current_y = control_topic[1]
                current_z = control_topic[2]
            elif current_x == target_x and target_y == current_y:
                print("arrived")
                arrived = True
        else:
            print("arrived else")
            if current_x == target_x and current_y == target_y and current_z == point_z:
                control_topic[2] = -current_z
                tmp_control = np.array(control_topic)
                current_z = -current_z
                #topic_list.append(tmp_control)
            elif current_x == target_x and current_y == target_y and current_z == -point_z:
                control_topic = np.array(topic_list[0])
                if current_z > 0:
                    control_topic[2] = -180
                else:
                    control_topic[2] = 180
                tmp_control = np.array(control_topic)
                current_x = tmp_control[0]
                current_y = tmp_control[1]
                current_z = tmp_control[2]
                topic_list.append(tmp_control)
            elif current_y == start_y and current_x != start_x:
                control_topic = np.array([start_x,start_y,current_z])
                topic_list.append(control_topic)
                current_x = control_topic[0]
                current_y = control_topic[1]
                current_z = 0
                topic_list.append(np.array([start_x, start_y, 0]))
                return topic_list
    ### sunpil modified source lines ###
    
    
#### hanul lines ####    
BURGER_MAX_LIN_VEL = 0.22
BURGER_MAX_ANG_VEL = 2.84
ANG_VEL_STEP_SIZE = 0.1
control_angular_vel = 0.0

def makeSimpleProfile(output, input, slop):
    if input > output:
        output = min( input, output + slop )
    elif input < output:
        output = max( input, output - slop )
    else:
        output = input

    return output

def constrain(input, low, high):
    if input < low:
      input = low
    elif input > high:
      input = high
    else:
      input = input

    return input

    
def sensor_callback(data) : 
    global encoder
    encoder = [data.left_encoder, data.right_encoder]

def joint_callback(data) :
    
    left_vel = data.velocity[0]
    right_vel = data.velocity[1]
    
    global velocity
    
    velocity = [left_vel, right_vel]
def checkAngularLimitVelocity(vel):

    vel = constrain(vel, -BURGER_MAX_ANG_VEL, BURGER_MAX_ANG_VEL)
    
def go_forward ():
    dif_vel = velocity[0] - velocity[1]
    if dif_vel < 0.0 :
        target_angular_vel = checkAngularLimitVelocity(1.14 * dif_vel)
        
    elif dif_vel > 0.0 : 
        target_angular_vel = checkAngularLimitVelocity(1.0 * dif_vel)
    
    control_angular_vel = makeSimpleProfile(control_angular_vel, target_angular_vel, (ANG_VEL_STEP_SIZE/2.0))
    
    move_cmd.angular.z = control_angular_vel
    

if __name__ == '__main__':
    try:
        ### sunpil modified source lines ###
        path_lists = path_calc(0, 0, 5, 2)
        count = 0
        
        ### hanul line ###
        sub_sensor = rospy.Subscriber('sensor_state', SensorState, sensor_callback)
        sub_joint = rospy.Subscriber('joint_states', JointState, joint_callback)
        ### hanul line ###
        
        
        while not rospy.is_shutdown():
            print(msg)
            GotoPoint(path_lists[count])
            count += 1
            if count > len(path_lists):
                break
        ### sunpil modified source lines ###

    except:
        rospy.loginfo("shutdown program.")

>>>>>>> wall_detection
